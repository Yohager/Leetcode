### Binary Indexed Tree and Segment Tree 
---
#### Binary Indexed Tree

假设有一个长度为$n$的数组，我们如何进行一些关于区间的快速操作

(如果数组是固定的则我们完全不需要使用这种数据结构，因为直接求前缀和即可使用，问题的关键在于这个数组常常需要更新，对应的前缀和也会产生更新)

- `update(idx,delta)` 将delta的值添加到idx位置的数字上。
- `prefixSum(idx)` 求解从数组的第一个位置到第idx个位置的前缀和。
- `rangeSum(si,ti)` 计算从si位置到ti位置的区间和。

举个例子，考虑前13个位置的和，我们可以将其表示为多个子区间的和：
`prefixSum(13)=RANGE(1,8)+RANGE(9,12)+RANGE(13,13)`.

另外，在使用树状数组之前我们需要进行树状数组的构建。
创建的过程大致如下：

- 初始化全为0的数组。
- 对于原数组中的每个位置的数字调用一次`update(idx,delta)`操作。
  
上述的创建过程时间复杂度为`O(NlogN)`. 另外还有一种`O(N)`的创建方式。

- 初始化长度为$n+1$的bits数组，先将原数组的数字放到前$n$位对应的位置。
- 对于从1到n的每个位置i：令`j=i+(i&(-i))`, 若`j<n+1`则有`bits[j] += bits[i]`.

我们在此文件夹下给出了一个示例`BinaryIndexedTree.py`中维护了一个树状数组，可以参考。

---

#### Segment Tree 

类似于树状数组，线段树使用对数时间复杂度进行区间查询和元素的更新，树状数组是利用索引的二进制表示来划分子序列，而线段树是不断利用二分来划分子序列。

举个例子：假设计算`[0,7]`区间和的值，我们可以使用二分`[0,3]`和`[4,7]`两个区间，进一步`[0,1],[2,3],[4,5],[6,7]`，再进一步二分变为一堆单个元素。

将线段树看成二叉树，每个节点保存了一个区间范围和一个区间和。

先从特殊情况开始考虑，如果$n$刚刚好是2的幂时，我们可以构建出一种完美的二叉树，第一个叶子节点`st[4]`存放数组第一个元素的值，第二个叶子存在第二个元素的值，以此类推。

求区间和`sumRange(i,j)`时，如果`st[i]`是右子节点则结果应该包含它单不包含其父亲，结果加上`st[i]`同时`i+=1`，最后将`i//=2`；如果`st[i]`是左子节点则它与其右兄弟在要求的区间内，此时`i//=2`. 对于`j`的处理同理。

如果$n$不是2的次幂，通常的做法是我们还是只需要创建一个长度为$2n$的数组。

线段树的实例在`SegmentTree.py`中。

---

#### 会使用到BIT和ST的场景

考虑有一个数组`arr`. 前面是问题，后面是解决方案。

- 数组不改变，求区间和：前缀和，树状数组，线段树。
- 多次修改某个值，然后求区间和：树状数组，线段树。
- 多次整体修改某个区间，求区间和：线段树，树状数组。
- 多次将某个区间变为同一个数，求区间和：线段树，树状数组。

在最后一种情况下我们使用线段树，其他情况下使用前缀和或者树状数组。

