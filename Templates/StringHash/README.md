### 字符串哈希
---

核心思想：将一个字符串通过函数映射到一个值域较小可以方便比较的范围内。
我们希望得到的是，当我们比较两个字符串的时候，如果hash函数映射得到的结果不同，那么两个字符串一定不相同，如果映射的结果相同，有极大的概率这两个字符串是一样的。

#### 多项式哈希

通常采用的方式是多项式hash函数，对于一个长度为$l$的字符串$s$来说，我们定义这个hash函数为：
$$f(s)=\sum_{i=1}^l s[i]\times b^{l-i}(\text{mod } M)$$
（注意到还有一些其他的hash函数，但是这个是比较常见的，主要是这个定义更加简便，别切可以类比为一个$b$进制数来帮助理解，下面的讨论都是基于这个hash函数进行的）

考虑如何选择参数的问题？
这里的$M$我们需要选择一个素数，$b$可以任意考虑，考虑两个不同的字符串，如果$f(s)=f(t)$，我们记录：
$$h(b)=f(s)-f(t)=\sum_{i=1}^l(s[i]-t[i])b^{l-i} (\text{mod} M)$$
其中$l=\max(|s|,|t|)$. 显然$h(b)$是一个$l-1$阶的非零多项式，如果$s$和$t$在选择$b$的情况下哈希碰撞了，那么$b$一定是$h(b)$的一个根。最多存在$l-1$个根，如果我们保证$b$是从$[0,M)$之间均匀随机选择的，那么碰撞的概率大概为$\frac{l-1}{M}$.

#### 性能分析
考虑假设需要比较$n$次，每次的错误率为$\frac{1}{M}$, 那么总的错误率大概为$1-(1-\frac{1}{M})^n$，在随机的数据之下，如果选择$M=10^9+7,n=10^6$时，错误率为$\frac{1}{1000}$，并不是可以忽略不计的。

单次计算一个字符串的hash的时间复杂度为$O(n)$，其中$n$表示为串的长度，与暴力匹配没有什么区别，如果要多次求解一个字符串子串的hash则每次都重新计算效率会十分低下。一般的操作是利用前缀的思想，对于一个字符串预处理出每个前缀的hash，将hash看作一个b进制数对$M$取模。

我们令$f_i(s)$表示为$f(s[1..i])$
即原字符串的前缀hash，按照定义我们有：
$$f_i(s)=s[1]\cdot b^{i-1}+s[2]\cdot b^{i-2}+\cdots +s[i-1]\cdot b + s[i] $$

用类似前缀和的思想我们希望快速求到$f(s[l..r])$, 按照定义有字符串$s[l..r]$的hash值为：
$$f(s[l..r])=s[l]\cdot b^{r-l}+s[l+1]\cdot b^{r-l-1}+\cdots + s[r-1]\cdot b + s[r]$$

从而我们可以知道：
$$f(s[l..r])=f_r(s)-f_{l-1}(s)\times s^{r-l+1}$$

这样即可通过$O(n)$的预处理得到前缀hash从而$O(1)$的时间快速求解每一个子串的hash值。

#### 字符串hash的应用

字符串匹配

求出模式串的hash值之后，求出文本串每个长度为模式串长度的子串的hash，分别于模式串的hash进行比较。

**允许k次失配的字符串匹配**

给定长度为$n$的字符串$s$, 长度为$m$的模式串$p$, 要求查找$s$中存在多少子串与模式串可以匹配，这个匹配的要求是长度相同且最多存在$k$个位置字符不同。

[Solution]：枚举所有可能的子串，假设当前枚举的子串为$s^{\prime}$通过hash+二分快速找到$s'$和$p$的第一个不同的位置，之后将$s'$与$p$在这个失配位置以及之前的部分全部删除，继续寻找下一个失配位置，最多失配$k$次，因此总的时间复杂度为$O(m+kn\log m)$. 

**最长回文子串**

[Solution]：先预处理正着和倒着的hash，二分答案，判断是否可行时枚举回文中心，hash判断两侧是否相等。

这个问题同样可以使用manacher算法在$O(n)$的时间内完成。

通过hash同样可以在$O(n)$的时间内解决这个问题，具体的方法是记$R_i$表示以$i$为结尾的最长的回文的长度，答案则为$\max_{i=1}^n R_i$, 考虑$R_i\leq R_{i-1}+2$，我们暴力地从$R_{i-1}+2$开始递减，直到找到第一个回文，记变量$z$表示当前枚举的$R_i$，初始为0，则$z$在$i$增大的时候都会增加2，之后每次的暴力循环都会减少1，从而暴力循环最多发生$2n$次，总的时间复杂度为$O(n)$. 

**最长公共子字符串**

[Solution]：给定$m$个总长度不超过$n$的非空字符串，查找所有字符串的最长公共子字符串，如果有多个，任意输出其中一个。

很显然如果存在长度为$k$的最长公共子字符串，那么$k-1$也存在，因此还是满足二分，假设现在长度为$k$, 我们需要将所有字符串长度为$k$的子串进行hash，将hash值放入$n$个hash表中进行存储，之后求交集。时间复杂度为$O(n\log \frac{n}{m})$.



